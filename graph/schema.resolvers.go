package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"pillbox/graph/model"
	"pillbox/internal/db"
	"time"

	"github.com/google/uuid"
)

// UpsertUser is the resolver for the upsertUser field.
func (r *mutationResolver) UpsertUser(ctx context.Context, input model.UserInput) (*model.User, error) {
	var passwordHash sql.NullString
	if input.Password != nil && *input.Password != "" {
		hashed, err := hashPassword(*input.Password)
		if err != nil {
			return nil, fmt.Errorf("hash password: %w", err)
		}
		passwordHash = sql.NullString{String: hashed, Valid: true}
	}

	if input.ID != nil && *input.ID != "" {
		record, err := r.Queries.UpdateUser(ctx, db.UpdateUserParams{
			Email:        input.Email,
			FullName:     input.FullName,
			Phone:        nullStringFromPtr(input.Phone),
			Timezone:     input.Timezone,
			PasswordHash: passwordHash,
			ID:           *input.ID,
		})
		if err != nil {
			return nil, fmt.Errorf("upsert user: %w", err)
		}
		return r.buildUserModel(ctx, record.ID, record.Email, record.FullName, record.Phone, record.Timezone, record.CreatedAt, record.UpdatedAt)
	} else {
		record, err := r.Queries.CreateUser(ctx, db.CreateUserParams{
			ID:           uuid.NewString(),
			Email:        input.Email,
			FullName:     input.FullName,
			Phone:        nullStringFromPtr(input.Phone),
			Timezone:     input.Timezone,
			PasswordHash: passwordHash,
		})
		if err != nil {
			return nil, fmt.Errorf("upsert user: %w", err)
		}
		return r.buildUserModel(ctx, record.ID, record.Email, record.FullName, record.Phone, record.Timezone, record.CreatedAt, record.UpdatedAt)
	}
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.User, error) {
	record, err := r.Queries.GetUserByEmail(ctx, input.Email)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("invalid email or password")
		}
		return nil, fmt.Errorf("get user: %w", err)
	}

	passwordHash := ""
	if record.PasswordHash.Valid {
		passwordHash = record.PasswordHash.String
	}
	if err := verifyPassword(passwordHash, input.Password); err != nil {
		return nil, fmt.Errorf("invalid email or password")
	}

	return r.buildUserModel(ctx, record.ID, record.Email, record.FullName, record.Phone, record.Timezone, record.CreatedAt, record.UpdatedAt)
}

// CreatePatient is the resolver for the createPatient field.
func (r *mutationResolver) CreatePatient(ctx context.Context, input model.PatientInput) (*model.Patient, error) {
	metaStr, err := encodeMetadata(input.Metadata)
	if err != nil {
		return nil, err
	}

	record, err := r.Queries.CreatePatient(ctx, db.CreatePatientParams{
		ID:                uuid.NewString(),
		UserID:            nullStringFromPtr(input.UserID),
		FirstName:         input.FirstName,
		LastName:          input.LastName,
		DateOfBirth:       formatNullableTimePtr(input.DateOfBirth),
		Gender:            nullStringFromPtr(input.Gender),
		Timezone:          input.Timezone,
		PreferredLanguage: nullStringFromPtr(input.PreferredLanguage),
		CaregiverName:     nullStringFromPtr(input.CaregiverName),
		CaregiverEmail:    nullStringFromPtr(input.CaregiverEmail),
		CaregiverPhone:    nullStringFromPtr(input.CaregiverPhone),
		Notes:             nullStringFromPtr(input.Notes),
		Metadata:          metaStr,
	})
	if err != nil {
		return nil, fmt.Errorf("create patient: %w", err)
	}

	return r.buildPatientModel(ctx, record)
}

// UpdatePatient is the resolver for the updatePatient field.
func (r *mutationResolver) UpdatePatient(ctx context.Context, id string, input model.PatientInput) (*model.Patient, error) {
	existing, err := r.Queries.GetPatient(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("load patient %s: %w", id, err)
	}

	userID := existing.UserID
	if input.UserID != nil {
		userID = nullStringFromPtr(input.UserID)
	}
	dateOfBirth := existing.DateOfBirth
	if input.DateOfBirth != nil {
		dateOfBirth = formatNullableTimePtr(input.DateOfBirth)
	}
	gender := existing.Gender
	if input.Gender != nil {
		gender = nullStringFromPtr(input.Gender)
	}
	preferredLanguage := existing.PreferredLanguage
	if input.PreferredLanguage != nil {
		preferredLanguage = nullStringFromPtr(input.PreferredLanguage)
	}
	caregiverName := existing.CaregiverName
	if input.CaregiverName != nil {
		caregiverName = nullStringFromPtr(input.CaregiverName)
	}
	caregiverEmail := existing.CaregiverEmail
	if input.CaregiverEmail != nil {
		caregiverEmail = nullStringFromPtr(input.CaregiverEmail)
	}
	caregiverPhone := existing.CaregiverPhone
	if input.CaregiverPhone != nil {
		caregiverPhone = nullStringFromPtr(input.CaregiverPhone)
	}
	notes := existing.Notes
	if input.Notes != nil {
		notes = nullStringFromPtr(input.Notes)
	}

	metaSource, err := decodeMetadata(existing.Metadata)
	if err != nil {
		return nil, err
	}
	if input.Metadata != nil {
		metaSource = input.Metadata
	}
	metaStr, err := encodeMetadata(metaSource)
	if err != nil {
		return nil, err
	}

	record, err := r.Queries.UpdatePatient(ctx, db.UpdatePatientParams{
		UserID:            userID,
		FirstName:         input.FirstName,
		LastName:          input.LastName,
		DateOfBirth:       dateOfBirth,
		Gender:            gender,
		Timezone:          input.Timezone,
		PreferredLanguage: preferredLanguage,
		CaregiverName:     caregiverName,
		CaregiverEmail:    caregiverEmail,
		CaregiverPhone:    caregiverPhone,
		Notes:             notes,
		Metadata:          metaStr,
		ID:                id,
	})
	if err != nil {
		return nil, fmt.Errorf("update patient: %w", err)
	}

	return r.buildPatientModel(ctx, record)
}

// UpsertMedication is the resolver for the upsertMedication field.
func (r *mutationResolver) UpsertMedication(ctx context.Context, input model.MedicationInput) (*model.Medication, error) {
	defaultStock := func(existing int64) int64 {
		if input.StockCount != nil {
			return int64(*input.StockCount)
		}
		return existing
	}
	defaultLowStock := func(existing int64) int64 {
		if input.LowStockThreshold != nil {
			return int64(*input.LowStockThreshold)
		}
		return existing
	}

	defaultMaxDailyDose := func(existing int64) int64 {
		if input.MaxDailyDose != nil {
			return int64(*input.MaxDailyDose)
		}
		return existing
	}

	if input.ID == nil || *input.ID == "" {
		stock := int64(0)
		if input.StockCount != nil {
			stock = int64(*input.StockCount)
		}
		lowStock := int64(0)
		if input.LowStockThreshold != nil {
			lowStock = int64(*input.LowStockThreshold)
		}

		metaStr, err := encodeMetadata(input.Metadata)
		if err != nil {
			return nil, err
		}

		record, err := r.Queries.CreateMedication(ctx, db.CreateMedicationParams{
			ID:                uuid.NewString(),
			PatientID:         input.PatientID,
			Name:              input.Name,
			Nickname:          nullStringFromPtr(input.Nickname),
			Color:             nullStringFromPtr(input.Color),
			Shape:             nullStringFromPtr(input.Shape),
			DosageForm:        nullStringFromPtr(input.DosageForm),
			Strength:          nullStringFromPtr(input.Strength),
			DosageMg:          nullIntFromPtr(input.DosageMg),
			Instructions:      nullStringFromPtr(input.Instructions),
			StockCount:        stock,
			LowStockThreshold: lowStock,
			CartridgeIndex:    nullIntFromPtr(input.CartridgeIndex),
			Manufacturer:      nullStringFromPtr(input.Manufacturer),
			ExternalID:        nullStringFromPtr(input.ExternalID),
			MaxDailyDose:      defaultMaxDailyDose(1),
			Metadata:          metaStr,
		})
		if err != nil {
			return nil, fmt.Errorf("create medication: %w", err)
		}
		return buildMedicationModel(record)
	}

	existing, err := r.Queries.GetMedication(ctx, *input.ID)
	if err != nil {
		return nil, fmt.Errorf("load medication %s: %w", *input.ID, err)
	}

	metaSource, err := decodeMetadata(existing.Metadata)
	if err != nil {
		return nil, err
	}
	if input.Metadata != nil {
		metaSource = input.Metadata
	}
	metaStr, err := encodeMetadata(metaSource)
	if err != nil {
		return nil, err
	}

	record, err := r.Queries.UpdateMedication(ctx, db.UpdateMedicationParams{
		Name:              input.Name,
		Nickname:          nullStringFromPtr(input.Nickname),
		Color:             nullStringFromPtr(input.Color),
		Shape:             nullStringFromPtr(input.Shape),
		DosageForm:        nullStringFromPtr(input.DosageForm),
		Strength:          nullStringFromPtr(input.Strength),
		DosageMg:          nullIntFromPtr(input.DosageMg),
		Instructions:      nullStringFromPtr(input.Instructions),
		StockCount:        defaultStock(existing.StockCount),
		LowStockThreshold: defaultLowStock(existing.LowStockThreshold),
		CartridgeIndex:    nullIntFromPtr(input.CartridgeIndex),
		Manufacturer:      nullStringFromPtr(input.Manufacturer),
		ExternalID:        nullStringFromPtr(input.ExternalID),
		MaxDailyDose:      defaultMaxDailyDose(existing.MaxDailyDose),
		Metadata:          metaStr,
		ID:                *input.ID,
	})
	if err != nil {
		return nil, fmt.Errorf("update medication: %w", err)
	}
	return buildMedicationModel(record)
}

// DeleteMedication is the resolver for the deleteMedication field.
func (r *mutationResolver) DeleteMedication(ctx context.Context, id string) (bool, error) {
	if err := r.Queries.DeleteMedication(ctx, id); err != nil {
		return false, fmt.Errorf("delete medication: %w", err)
	}
	return true, nil
}

// CreateSchedule is the resolver for the createSchedule field.
func (r *mutationResolver) CreateSchedule(ctx context.Context, input model.ScheduleInput) (*model.Schedule, error) {
	if len(input.Items) == 0 {
		return nil, fmt.Errorf("schedule must include at least one item")
	}

	status := model.ScheduleStatusActive
	if input.Status != nil {
		status = *input.Status
	}

	metaStr, err := encodeMetadata(input.Metadata)
	if err != nil {
		return nil, err
	}

	var created db.Schedule
	err = r.withTx(ctx, func(qtx *db.Queries) error {
		schedule, err := qtx.CreateSchedule(ctx, db.CreateScheduleParams{
			ID:                    uuid.NewString(),
			PatientID:             input.PatientID,
			Title:                 input.Title,
			Timezone:              input.Timezone,
			Rrule:                 input.Rrule,
			StartDateIso:          formatDBTime(input.StartDateIso),
			EndDateIso:            formatNullableTimePtr(input.EndDateIso),
			LockoutMinutes:        int64(input.LockoutMinutes),
			SnoozeIntervalMinutes: int64(input.SnoozeIntervalMinutes),
			SnoozeMax:             int64(input.SnoozeMax),
			Status:                string(status),
			Notes:                 nullStringFromPtr(input.Notes),
			Metadata:              metaStr,
		})
		if err != nil {
			return err
		}
		created = schedule

		for _, item := range input.Items {
			if _, err := qtx.CreateScheduleItem(ctx, db.CreateScheduleItemParams{
				ID:           uuid.NewString(),
				ScheduleID:   schedule.ID,
				MedicationID: item.MedicationID,
				Qty:          int64(item.Qty),
				Instructions: nullStringFromPtr(item.Instructions),
			}); err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return nil, fmt.Errorf("create schedule: %w", err)
	}

	return r.buildScheduleModel(ctx, created)
}

// UpdateSchedule is the resolver for the updateSchedule field.
func (r *mutationResolver) UpdateSchedule(ctx context.Context, id string, input model.ScheduleInput) (*model.Schedule, error) {
	if len(input.Items) == 0 {
		return nil, fmt.Errorf("schedule must include at least one item")
	}

	status := model.ScheduleStatusActive
	if input.Status != nil {
		status = *input.Status
	}
	metaStr, err := encodeMetadata(input.Metadata)
	if err != nil {
		return nil, err
	}

	var updated db.Schedule
	err = r.withTx(ctx, func(qtx *db.Queries) error {
		schedule, err := qtx.UpdateSchedule(ctx, db.UpdateScheduleParams{
			Title:                 input.Title,
			Timezone:              input.Timezone,
			Rrule:                 input.Rrule,
			StartDateIso:          formatDBTime(input.StartDateIso),
			EndDateIso:            formatNullableTimePtr(input.EndDateIso),
			LockoutMinutes:        int64(input.LockoutMinutes),
			SnoozeIntervalMinutes: int64(input.SnoozeIntervalMinutes),
			SnoozeMax:             int64(input.SnoozeMax),
			Status:                string(status),
			Notes:                 nullStringFromPtr(input.Notes),
			Metadata:              metaStr,
			ID:                    id,
		})
		if err != nil {
			return err
		}
		updated = schedule

		if err := qtx.DeleteScheduleItemsBySchedule(ctx, id); err != nil {
			return err
		}
		for _, item := range input.Items {
			if _, err := qtx.CreateScheduleItem(ctx, db.CreateScheduleItemParams{
				ID:           uuid.NewString(),
				ScheduleID:   id,
				MedicationID: item.MedicationID,
				Qty:          int64(item.Qty),
				Instructions: nullStringFromPtr(item.Instructions),
			}); err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return nil, fmt.Errorf("update schedule: %w", err)
	}

	return r.buildScheduleModel(ctx, updated)
}

// ArchiveSchedule is the resolver for the archiveSchedule field.
func (r *mutationResolver) ArchiveSchedule(ctx context.Context, id string) (*model.Schedule, error) {
	record, err := r.Queries.ArchiveSchedule(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("archive schedule: %w", err)
	}
	return r.buildScheduleModel(ctx, record)
}

// RecordDispenseAction is the resolver for the recordDispenseAction field.
func (r *mutationResolver) RecordDispenseAction(ctx context.Context, input model.DispenseActionInput) (*model.DispenseEvent, error) {
	metadataStr, err := encodeMetadata(input.Metadata)
	if err != nil {
		return nil, err
	}

	var record db.DispenseEvent
	if input.EventID != nil && *input.EventID != "" {
		record, err = r.Queries.UpdateDispenseEvent(ctx, db.UpdateDispenseEventParams{
			PatientID:      input.PatientID,
			ScheduleID:     input.ScheduleID,
			ScheduleItemID: nullStringFromPtr(input.ScheduleItemID),
			DueAtIso:       formatDBTime(input.DueAtIso),
			ActedAtIso:     formatNullableTimePtr(input.ActedAtIso),
			Status:         string(input.Status),
			ActionSource:   nullStringFromPtr(input.ActionSource),
			Notes:          nullStringFromPtr(input.Notes),
			Metadata:       metadataStr,
			ID:             *input.EventID,
		})
	} else {
		record, err = r.Queries.CreateDispenseEvent(ctx, db.CreateDispenseEventParams{
			ID:             uuid.NewString(),
			PatientID:      input.PatientID,
			ScheduleID:     input.ScheduleID,
			ScheduleItemID: nullStringFromPtr(input.ScheduleItemID),
			DueAtIso:       formatDBTime(input.DueAtIso),
			ActedAtIso:     formatNullableTimePtr(input.ActedAtIso),
			Status:         string(input.Status),
			ActionSource:   nullStringFromPtr(input.ActionSource),
			Notes:          nullStringFromPtr(input.Notes),
			Metadata:       metadataStr,
		})
	}
	if err != nil {
		return nil, fmt.Errorf("record dispense event: %w", err)
	}

	return buildDispenseEvent(record)
}

// Ping is the resolver for the ping field.
func (r *queryResolver) Ping(ctx context.Context) (string, error) {
	panic(fmt.Errorf("not implemented: Ping - ping"))
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	records, err := r.Queries.ListUsers(ctx)
	if err != nil {
		return nil, fmt.Errorf("list users: %w", err)
	}
	result := make([]*model.User, 0, len(records))
	for _, rec := range records {
		user, err := r.buildUserModel(ctx, rec.ID, rec.Email, rec.FullName, rec.Phone, rec.Timezone, rec.CreatedAt, rec.UpdatedAt)
		if err != nil {
			return nil, err
		}
		result = append(result, user)
	}
	return result, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	record, err := r.Queries.GetUser(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("get user: %w", err)
	}
	return r.buildUserModel(ctx, record.ID, record.Email, record.FullName, record.Phone, record.Timezone, record.CreatedAt, record.UpdatedAt)
}

// UserByEmail is the resolver for the userByEmail field.
func (r *queryResolver) UserByEmail(ctx context.Context, email string) (*model.User, error) {
	record, err := r.Queries.GetUserByEmail(ctx, email)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil
		}
		return nil, fmt.Errorf("get user by email: %w", err)
	}
	return r.buildUserModel(ctx, record.ID, record.Email, record.FullName, record.Phone, record.Timezone, record.CreatedAt, record.UpdatedAt)
}

// Patient is the resolver for the patient field.
func (r *queryResolver) Patient(ctx context.Context, id string) (*model.Patient, error) {
	record, err := r.Queries.GetPatient(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("get patient: %w", err)
	}
	return r.buildPatientModel(ctx, record)
}

// Patients is the resolver for the patients field.
func (r *queryResolver) Patients(ctx context.Context, userID *string) ([]*model.Patient, error) {
	var (
		records []db.Patient
		err     error
	)
	if userID != nil {
		records, err = r.Queries.ListPatientsByUser(ctx, sql.NullString{String: *userID, Valid: true})
	} else {
		records, err = r.Queries.ListPatients(ctx)
	}
	if err != nil {
		return nil, fmt.Errorf("list patients: %w", err)
	}

	result := make([]*model.Patient, 0, len(records))
	for _, rec := range records {
		patient, err := r.buildPatientModel(ctx, rec)
		if err != nil {
			return nil, err
		}
		result = append(result, patient)
	}
	return result, nil
}

// Medications is the resolver for the medications field.
func (r *queryResolver) Medications(ctx context.Context, patientID string) ([]*model.Medication, error) {
	return r.loadMedications(ctx, patientID)
}

// Medication is the resolver for the medication field.
func (r *queryResolver) Medication(ctx context.Context, id string) (*model.Medication, error) {
	record, err := r.Queries.GetMedication(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("get medication: %w", err)
	}
	return buildMedicationModel(record)
}

// Schedules is the resolver for the schedules field.
func (r *queryResolver) Schedules(ctx context.Context, patientID string) ([]*model.Schedule, error) {
	return r.loadSchedules(ctx, patientID)
}

// Schedule is the resolver for the schedule field.
func (r *queryResolver) Schedule(ctx context.Context, id string) (*model.Schedule, error) {
	record, err := r.Queries.GetSchedule(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("get schedule: %w", err)
	}
	return r.buildScheduleModel(ctx, record)
}

// DispenseEvents is the resolver for the dispenseEvents field.
func (r *queryResolver) DispenseEvents(ctx context.Context, patientID string, rangeArg *model.DateRangeInput) ([]*model.DispenseEvent, error) {
	start := time.Now().Add(-30 * 24 * time.Hour)
	end := time.Now().Add(30 * 24 * time.Hour)
	if rangeArg != nil {
		start = rangeArg.Start
		end = rangeArg.End
		if !end.After(start) {
			return nil, fmt.Errorf("range end must be after start")
		}
	}

	events, err := r.fetchEvents(ctx, patientID, start, end)
	if err != nil {
		return nil, err
	}
	return events, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
