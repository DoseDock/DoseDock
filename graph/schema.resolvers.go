package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"pillbox/graph/model"
	"pillbox/internal/db"
	"time"

	"github.com/google/uuid"
)

// UpsertUser is the resolver for the upsertUser field.
func (r *mutationResolver) UpsertUser(ctx context.Context, input model.UserInput) (*model.User, error) {
	var passwordHash sql.NullString
	if input.Password != nil && *input.Password != "" {
		hashed, err := hashPassword(*input.Password)
		if err != nil {
			return nil, fmt.Errorf("hash password: %w", err)
		}
		passwordHash = sql.NullString{String: hashed, Valid: true}
	}

	if input.ID != nil && *input.ID != "" {
		record, err := r.Queries.UpdateUser(ctx, db.UpdateUserParams{
			Email:        input.Email,
			FullName:     input.FullName,
			Phone:        nullStringFromPtr(input.Phone),
			Timezone:     input.Timezone,
			PasswordHash: passwordHash,
			ID:           *input.ID,
		})
		if err != nil {
			return nil, fmt.Errorf("upsert user: %w", err)
		}
		return r.buildUserModel(ctx, record.ID, record.Email, record.FullName, record.Phone, record.Timezone, record.CreatedAt, record.UpdatedAt)
	} else {
		record, err := r.Queries.CreateUser(ctx, db.CreateUserParams{
			ID:           uuid.NewString(),
			Email:        input.Email,
			FullName:     input.FullName,
			Phone:        nullStringFromPtr(input.Phone),
			Timezone:     input.Timezone,
			PasswordHash: passwordHash,
		})
		if err != nil {
			return nil, fmt.Errorf("upsert user: %w", err)
		}
		return r.buildUserModel(ctx, record.ID, record.Email, record.FullName, record.Phone, record.Timezone, record.CreatedAt, record.UpdatedAt)
	}
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.User, error) {
	record, err := r.Queries.GetUserByEmail(ctx, input.Email)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("invalid email or password")
		}
		return nil, fmt.Errorf("get user: %w", err)
	}

	passwordHash := ""
	if record.PasswordHash.Valid {
		passwordHash = record.PasswordHash.String
	}
	if err := verifyPassword(passwordHash, input.Password); err != nil {
		return nil, fmt.Errorf("invalid email or password")
	}

	return r.buildUserModel(ctx, record.ID, record.Email, record.FullName, record.Phone, record.Timezone, record.CreatedAt, record.UpdatedAt)
}

// CreatePatient is the resolver for the createPatient field.
func (r *mutationResolver) CreatePatient(ctx context.Context, input model.PatientInput) (*model.Patient, error) {
	record, err := r.Queries.CreatePatient(ctx, db.CreatePatientParams{
		ID:        uuid.NewString(),
		UserID:    nullStringFromPtr(input.UserID),
		FirstName: input.FirstName,
		LastName:  input.LastName,
		Timezone:  input.Timezone,
	})
	if err != nil {
		return nil, fmt.Errorf("create patient: %w", err)
	}

	return r.buildPatientModel(ctx, record)
}

// UpdatePatient is the resolver for the updatePatient field.
func (r *mutationResolver) UpdatePatient(ctx context.Context, id string, input model.PatientInput) (*model.Patient, error) {
	existing, err := r.Queries.GetPatient(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("load patient %s: %w", id, err)
	}

	userID := existing.UserID
	if input.UserID != nil {
		userID = nullStringFromPtr(input.UserID)
	}

	record, err := r.Queries.UpdatePatient(ctx, db.UpdatePatientParams{
		UserID:    userID,
		FirstName: input.FirstName,
		LastName:  input.LastName,
		Timezone:  input.Timezone,
		ID:        id,
	})
	if err != nil {
		return nil, fmt.Errorf("update patient: %w", err)
	}

	return r.buildPatientModel(ctx, record)
}

// UpsertMedication is the resolver for the upsertMedication field.
func (r *mutationResolver) UpsertMedication(ctx context.Context, input model.MedicationInput) (*model.Medication, error) {
	defaultStock := func(existing int64) int64 {
		if input.StockCount != nil {
			return int64(*input.StockCount)
		}
		return existing
	}
	defaultLowStock := func(existing int64) int64 {
		if input.LowStockThreshold != nil {
			return int64(*input.LowStockThreshold)
		}
		return existing
	}
	defaultMaxDailyDose := func(existing int64) int64 {
		if input.MaxDailyDose != nil {
			return int64(*input.MaxDailyDose)
		}
		return existing
	}

	if input.ID == nil || *input.ID == "" {
		stock := int64(0)
		if input.StockCount != nil {
			stock = int64(*input.StockCount)
		}
		lowStock := int64(0)
		if input.LowStockThreshold != nil {
			lowStock = int64(*input.LowStockThreshold)
		}

		record, err := r.Queries.CreateMedication(ctx, db.CreateMedicationParams{
			ID:                uuid.NewString(),
			PatientID:         input.PatientID,
			Name:              input.Name,
			Color:             nullStringFromPtr(input.Color),
			StockCount:        stock,
			LowStockThreshold: lowStock,
			CartridgeIndex:    nullIntFromPtr(input.CartridgeIndex),
			MaxDailyDose:      defaultMaxDailyDose(1),
		})
		if err != nil {
			return nil, fmt.Errorf("create medication: %w", err)
		}
		return buildMedicationModel(record)
	}

	existing, err := r.Queries.GetMedication(ctx, *input.ID)
	if err != nil {
		return nil, fmt.Errorf("load medication %s: %w", *input.ID, err)
	}

	record, err := r.Queries.UpdateMedication(ctx, db.UpdateMedicationParams{
		Name:              input.Name,
		Color:             nullStringFromPtr(input.Color),
		StockCount:        defaultStock(existing.StockCount),
		LowStockThreshold: defaultLowStock(existing.LowStockThreshold),
		CartridgeIndex:    nullIntFromPtr(input.CartridgeIndex),
		MaxDailyDose:      defaultMaxDailyDose(existing.MaxDailyDose),
		ID:                *input.ID,
	})
	if err != nil {
		return nil, fmt.Errorf("update medication: %w", err)
	}
	return buildMedicationModel(record)
}

// DeleteMedication is the resolver for the deleteMedication field.
func (r *mutationResolver) DeleteMedication(ctx context.Context, id string) (bool, error) {
	if err := r.Queries.DeleteMedication(ctx, id); err != nil {
		return false, fmt.Errorf("delete medication: %w", err)
	}
	return true, nil
}

// CreateSchedule is the resolver for the createSchedule field.
func (r *mutationResolver) CreateSchedule(ctx context.Context, input model.ScheduleInput) (*model.Schedule, error) {
	if len(input.Items) == 0 {
		return nil, fmt.Errorf("schedule must include at least one item")
	}

	status := model.ScheduleStatusActive
	if input.Status != nil {
		status = *input.Status
	}

	var created db.Schedule
	err := r.withTx(ctx, func(qtx *db.Queries) error {
		schedule, err := qtx.CreateSchedule(ctx, db.CreateScheduleParams{
			ID:             uuid.NewString(),
			PatientID:      input.PatientID,
			Title:          input.Title,
			Timezone:       input.Timezone,
			Rrule:          input.Rrule,
			StartDateIso:   formatDBTime(input.StartDateIso),
			EndDateIso:     formatNullableTimePtr(input.EndDateIso),
			LockoutMinutes: int64(input.LockoutMinutes),
			Status:         string(status),
		})
		if err != nil {
			return err
		}
		created = schedule

		for _, item := range input.Items {
			if _, err := qtx.CreateScheduleItem(ctx, db.CreateScheduleItemParams{
				ID:           uuid.NewString(),
				ScheduleID:   schedule.ID,
				MedicationID: item.MedicationID,
				Qty:          int64(item.Qty),
			}); err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return nil, fmt.Errorf("create schedule: %w", err)
	}

	return r.buildScheduleModel(ctx, created)
}

// UpdateSchedule is the resolver for the updateSchedule field.
func (r *mutationResolver) UpdateSchedule(ctx context.Context, id string, input model.ScheduleInput) (*model.Schedule, error) {
	if len(input.Items) == 0 {
		return nil, fmt.Errorf("schedule must include at least one item")
	}

	status := model.ScheduleStatusActive
	if input.Status != nil {
		status = *input.Status
	}

	var updated db.Schedule
	err := r.withTx(ctx, func(qtx *db.Queries) error {
		schedule, err := qtx.UpdateSchedule(ctx, db.UpdateScheduleParams{
			Title:          input.Title,
			Timezone:       input.Timezone,
			Rrule:          input.Rrule,
			StartDateIso:   formatDBTime(input.StartDateIso),
			EndDateIso:     formatNullableTimePtr(input.EndDateIso),
			LockoutMinutes: int64(input.LockoutMinutes),
			Status:         string(status),
			ID:             id,
		})
		if err != nil {
			return err
		}
		updated = schedule

		if err := qtx.DeleteScheduleItemsBySchedule(ctx, id); err != nil {
			return err
		}
		for _, item := range input.Items {
			if _, err := qtx.CreateScheduleItem(ctx, db.CreateScheduleItemParams{
				ID:           uuid.NewString(),
				ScheduleID:   id,
				MedicationID: item.MedicationID,
				Qty:          int64(item.Qty),
			}); err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return nil, fmt.Errorf("update schedule: %w", err)
	}

	return r.buildScheduleModel(ctx, updated)
}

// ArchiveSchedule is the resolver for the archiveSchedule field.
func (r *mutationResolver) ArchiveSchedule(ctx context.Context, id string) (*model.Schedule, error) {
	record, err := r.Queries.ArchiveSchedule(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("archive schedule: %w", err)
	}
	return r.buildScheduleModel(ctx, record)
}

// RecordDispenseAction is the resolver for the recordDispenseAction field.
func (r *mutationResolver) RecordDispenseAction(ctx context.Context, input model.DispenseActionInput) (*model.DispenseEvent, error) {
	var record db.DispenseEvent
	var err error

	if input.EventID != nil && *input.EventID != "" {
		record, err = r.Queries.UpdateDispenseEvent(ctx, db.UpdateDispenseEventParams{
			PatientID:    input.PatientID,
			ScheduleID:   input.ScheduleID,
			DueAtIso:     formatDBTime(input.DueAtIso),
			ActedAtIso:   formatNullableTimePtr(input.ActedAtIso),
			Status:       string(input.Status),
			ActionSource: nullStringFromPtr(input.ActionSource),
			ID:           *input.EventID,
		})
	} else {
		record, err = r.Queries.CreateDispenseEvent(ctx, db.CreateDispenseEventParams{
			ID:           uuid.NewString(),
			PatientID:    input.PatientID,
			ScheduleID:   input.ScheduleID,
			DueAtIso:     formatDBTime(input.DueAtIso),
			ActedAtIso:   formatNullableTimePtr(input.ActedAtIso),
			Status:       string(input.Status),
			ActionSource: nullStringFromPtr(input.ActionSource),
		})
	}
	if err != nil {
		return nil, fmt.Errorf("record dispense event: %w", err)
	}

	return buildDispenseEvent(record)
}

// Ping is the resolver for the ping field.
func (r *queryResolver) Ping(ctx context.Context) (string, error) {
	return "pong", nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	records, err := r.Queries.ListUsers(ctx)
	if err != nil {
		return nil, fmt.Errorf("list users: %w", err)
	}
	result := make([]*model.User, 0, len(records))
	for _, rec := range records {
		user, err := r.buildUserModel(ctx, rec.ID, rec.Email, rec.FullName, rec.Phone, rec.Timezone, rec.CreatedAt, rec.UpdatedAt)
		if err != nil {
			return nil, err
		}
		result = append(result, user)
	}
	return result, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	record, err := r.Queries.GetUser(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("get user: %w", err)
	}
	return r.buildUserModel(ctx, record.ID, record.Email, record.FullName, record.Phone, record.Timezone, record.CreatedAt, record.UpdatedAt)
}

// UserByEmail is the resolver for the userByEmail field.
func (r *queryResolver) UserByEmail(ctx context.Context, email string) (*model.User, error) {
	record, err := r.Queries.GetUserByEmail(ctx, email)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil
		}
		return nil, fmt.Errorf("get user by email: %w", err)
	}
	return r.buildUserModel(ctx, record.ID, record.Email, record.FullName, record.Phone, record.Timezone, record.CreatedAt, record.UpdatedAt)
}

// Patient is the resolver for the patient field.
func (r *queryResolver) Patient(ctx context.Context, id string) (*model.Patient, error) {
	record, err := r.Queries.GetPatient(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("get patient: %w", err)
	}
	return r.buildPatientModel(ctx, record)
}

// Patients is the resolver for the patients field.
func (r *queryResolver) Patients(ctx context.Context, userID *string) ([]*model.Patient, error) {
	var (
		records []db.Patient
		err     error
	)
	if userID != nil {
		records, err = r.Queries.ListPatientsByUser(ctx, sql.NullString{String: *userID, Valid: true})
	} else {
		records, err = r.Queries.ListPatients(ctx)
	}
	if err != nil {
		return nil, fmt.Errorf("list patients: %w", err)
	}

	result := make([]*model.Patient, 0, len(records))
	for _, rec := range records {
		patient, err := r.buildPatientModel(ctx, rec)
		if err != nil {
			return nil, err
		}
		result = append(result, patient)
	}
	return result, nil
}

// Medications is the resolver for the medications field.
func (r *queryResolver) Medications(ctx context.Context, patientID string) ([]*model.Medication, error) {
	return r.loadMedications(ctx, patientID)
}

// Medication is the resolver for the medication field.
func (r *queryResolver) Medication(ctx context.Context, id string) (*model.Medication, error) {
	record, err := r.Queries.GetMedication(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("get medication: %w", err)
	}
	return buildMedicationModel(record)
}

// Schedules is the resolver for the schedules field.
func (r *queryResolver) Schedules(ctx context.Context, patientID string) ([]*model.Schedule, error) {
	return r.loadSchedules(ctx, patientID)
}

// Schedule is the resolver for the schedule field.
func (r *queryResolver) Schedule(ctx context.Context, id string) (*model.Schedule, error) {
	record, err := r.Queries.GetSchedule(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("get schedule: %w", err)
	}
	return r.buildScheduleModel(ctx, record)
}

// DispenseEvents is the resolver for the dispenseEvents field.
func (r *queryResolver) DispenseEvents(ctx context.Context, patientID string, rangeArg *model.DateRangeInput) ([]*model.DispenseEvent, error) {
	start := time.Now().Add(-30 * 24 * time.Hour)
	end := time.Now().Add(30 * 24 * time.Hour)
	if rangeArg != nil {
		start = rangeArg.Start
		end = rangeArg.End
		if !end.After(start) {
			return nil, fmt.Errorf("range end must be after start")
		}
	}

	events, err := r.fetchEvents(ctx, patientID, start, end)
	if err != nil {
		return nil, err
	}
	return events, nil
}

// DueNow is the resolver for the dueNow field.
// Returns schedules that are due within the specified time window (default +-1 minute).
// This endpoint is designed for firmware to poll every minute.
func (r *queryResolver) DueNow(ctx context.Context, patientID string, windowMinutes *int) ([]*model.DueSchedule, error) {
	// Default to 1 minute window
	window := 1
	if windowMinutes != nil && *windowMinutes > 0 {
		window = *windowMinutes
	}

	// Get all active schedules for this patient
	scheduleRows, err := r.Queries.ListSchedulesByPatient(ctx, patientID)
	if err != nil {
		return nil, fmt.Errorf("list schedules: %w", err)
	}

	result := make([]*model.DueSchedule, 0)

	for _, scheduleRow := range scheduleRows {
		// Only check ACTIVE schedules
		if scheduleRow.Status != string(model.ScheduleStatusActive) {
			continue
		}

		// Parse start date
		startDate, err := parseDBTime(scheduleRow.StartDateIso)
		if err != nil {
			continue // Skip invalid schedules
		}

		// Parse optional end date
		var endDate *time.Time
		if scheduleRow.EndDateIso.Valid {
			parsed, err := parseDBTime(scheduleRow.EndDateIso.String)
			if err == nil {
				endDate = &parsed
			}
		}

		// Check if this schedule is due now
		dueTime, err := IsScheduleDueNow(scheduleRow.Rrule, startDate, endDate, window)
		if err != nil {
			// Log but continue - don't fail the whole query for one bad RRULE
			continue
		}

		if dueTime == nil {
			// Not due right now
			continue
		}

		// Build the full schedule model
		schedule, err := r.buildScheduleModel(ctx, scheduleRow)
		if err != nil {
			return nil, err
		}

		// Build DueMedication list from schedule items
		dueMeds := make([]*model.DueMedication, 0, len(schedule.Items))
		for _, item := range schedule.Items {
			dueMeds = append(dueMeds, &model.DueMedication{
				Medication: item.Medication,
				Qty:        item.Qty,
				SiloSlot:   item.Medication.CartridgeIndex,
			})
		}

		result = append(result, &model.DueSchedule{
			Schedule:    schedule,
			DueAtIso:    *dueTime,
			Medications: dueMeds,
		})
	}

	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
