// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: schedules.sql

package db

import (
	"context"
	"database/sql"
)

const archiveSchedule = `-- name: ArchiveSchedule :one
UPDATE schedules
SET
  status = 'ARCHIVED',
  updated_at = datetime('now')
WHERE id = ?
RETURNING id, patient_id, title, timezone, rrule, start_date_iso, end_date_iso, lockout_minutes, status, created_at, updated_at
`

func (q *Queries) ArchiveSchedule(ctx context.Context, id string) (Schedule, error) {
	row := q.queryRow(ctx, q.archiveScheduleStmt, archiveSchedule, id)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.Title,
		&i.Timezone,
		&i.Rrule,
		&i.StartDateIso,
		&i.EndDateIso,
		&i.LockoutMinutes,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSchedule = `-- name: CreateSchedule :one
INSERT INTO schedules (id, patient_id, title, timezone, rrule, start_date_iso, end_date_iso, lockout_minutes, status)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, patient_id, title, timezone, rrule, start_date_iso, end_date_iso, lockout_minutes, status, created_at, updated_at
`

type CreateScheduleParams struct {
	ID             string         `json:"id"`
	PatientID      string         `json:"patient_id"`
	Title          string         `json:"title"`
	Timezone       string         `json:"timezone"`
	Rrule          string         `json:"rrule"`
	StartDateIso   string         `json:"start_date_iso"`
	EndDateIso     sql.NullString `json:"end_date_iso"`
	LockoutMinutes int64          `json:"lockout_minutes"`
	Status         string         `json:"status"`
}

func (q *Queries) CreateSchedule(ctx context.Context, arg CreateScheduleParams) (Schedule, error) {
	row := q.queryRow(ctx, q.createScheduleStmt, createSchedule,
		arg.ID,
		arg.PatientID,
		arg.Title,
		arg.Timezone,
		arg.Rrule,
		arg.StartDateIso,
		arg.EndDateIso,
		arg.LockoutMinutes,
		arg.Status,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.Title,
		&i.Timezone,
		&i.Rrule,
		&i.StartDateIso,
		&i.EndDateIso,
		&i.LockoutMinutes,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createScheduleItem = `-- name: CreateScheduleItem :one
INSERT INTO schedule_items (id, schedule_id, medication_id, qty)
VALUES (?, ?, ?, ?)
RETURNING id, schedule_id, medication_id, qty
`

type CreateScheduleItemParams struct {
	ID           string `json:"id"`
	ScheduleID   string `json:"schedule_id"`
	MedicationID string `json:"medication_id"`
	Qty          int64  `json:"qty"`
}

func (q *Queries) CreateScheduleItem(ctx context.Context, arg CreateScheduleItemParams) (ScheduleItem, error) {
	row := q.queryRow(ctx, q.createScheduleItemStmt, createScheduleItem,
		arg.ID,
		arg.ScheduleID,
		arg.MedicationID,
		arg.Qty,
	)
	var i ScheduleItem
	err := row.Scan(
		&i.ID,
		&i.ScheduleID,
		&i.MedicationID,
		&i.Qty,
	)
	return i, err
}

const deleteScheduleItemsBySchedule = `-- name: DeleteScheduleItemsBySchedule :exec
DELETE FROM schedule_items
WHERE schedule_id = ?
`

func (q *Queries) DeleteScheduleItemsBySchedule(ctx context.Context, scheduleID string) error {
	_, err := q.exec(ctx, q.deleteScheduleItemsByScheduleStmt, deleteScheduleItemsBySchedule, scheduleID)
	return err
}

const getSchedule = `-- name: GetSchedule :one
SELECT id, patient_id, title, timezone, rrule, start_date_iso, end_date_iso, lockout_minutes, status, created_at, updated_at
FROM schedules
WHERE id = ?
`

func (q *Queries) GetSchedule(ctx context.Context, id string) (Schedule, error) {
	row := q.queryRow(ctx, q.getScheduleStmt, getSchedule, id)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.Title,
		&i.Timezone,
		&i.Rrule,
		&i.StartDateIso,
		&i.EndDateIso,
		&i.LockoutMinutes,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listScheduleItemsBySchedule = `-- name: ListScheduleItemsBySchedule :many
SELECT
  si.id AS schedule_item_id,
  si.schedule_id,
  si.medication_id AS schedule_medication_id,
  si.qty,
  m.id AS medication_id,
  m.patient_id AS medication_patient_id,
  m.name AS medication_name,
  m.color AS medication_color,
  m.stock_count AS medication_stock_count,
  m.low_stock_threshold AS medication_low_stock_threshold,
  m.cartridge_index AS medication_cartridge_index,
  m.max_daily_dose AS medication_max_daily_dose,
  m.created_at AS medication_created_at,
  m.updated_at AS medication_updated_at
FROM schedule_items si
JOIN medications m ON m.id = si.medication_id
WHERE si.schedule_id = ?
ORDER BY m.name
`

type ListScheduleItemsByScheduleRow struct {
	ScheduleItemID              string         `json:"schedule_item_id"`
	ScheduleID                  string         `json:"schedule_id"`
	ScheduleMedicationID        string         `json:"schedule_medication_id"`
	Qty                         int64          `json:"qty"`
	MedicationID                string         `json:"medication_id"`
	MedicationPatientID         string         `json:"medication_patient_id"`
	MedicationName              string         `json:"medication_name"`
	MedicationColor             sql.NullString `json:"medication_color"`
	MedicationStockCount        int64          `json:"medication_stock_count"`
	MedicationLowStockThreshold int64          `json:"medication_low_stock_threshold"`
	MedicationCartridgeIndex    sql.NullInt64  `json:"medication_cartridge_index"`
	MedicationMaxDailyDose      int64          `json:"medication_max_daily_dose"`
	MedicationCreatedAt         string         `json:"medication_created_at"`
	MedicationUpdatedAt         string         `json:"medication_updated_at"`
}

func (q *Queries) ListScheduleItemsBySchedule(ctx context.Context, scheduleID string) ([]ListScheduleItemsByScheduleRow, error) {
	rows, err := q.query(ctx, q.listScheduleItemsByScheduleStmt, listScheduleItemsBySchedule, scheduleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListScheduleItemsByScheduleRow{}
	for rows.Next() {
		var i ListScheduleItemsByScheduleRow
		if err := rows.Scan(
			&i.ScheduleItemID,
			&i.ScheduleID,
			&i.ScheduleMedicationID,
			&i.Qty,
			&i.MedicationID,
			&i.MedicationPatientID,
			&i.MedicationName,
			&i.MedicationColor,
			&i.MedicationStockCount,
			&i.MedicationLowStockThreshold,
			&i.MedicationCartridgeIndex,
			&i.MedicationMaxDailyDose,
			&i.MedicationCreatedAt,
			&i.MedicationUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSchedulesByPatient = `-- name: ListSchedulesByPatient :many
SELECT id, patient_id, title, timezone, rrule, start_date_iso, end_date_iso, lockout_minutes, status, created_at, updated_at
FROM schedules
WHERE patient_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListSchedulesByPatient(ctx context.Context, patientID string) ([]Schedule, error) {
	rows, err := q.query(ctx, q.listSchedulesByPatientStmt, listSchedulesByPatient, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Schedule{}
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.Title,
			&i.Timezone,
			&i.Rrule,
			&i.StartDateIso,
			&i.EndDateIso,
			&i.LockoutMinutes,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSchedule = `-- name: UpdateSchedule :one
UPDATE schedules
SET
  title = ?,
  timezone = ?,
  rrule = ?,
  start_date_iso = ?,
  end_date_iso = ?,
  lockout_minutes = ?,
  status = ?,
  updated_at = datetime('now')
WHERE id = ?
RETURNING id, patient_id, title, timezone, rrule, start_date_iso, end_date_iso, lockout_minutes, status, created_at, updated_at
`

type UpdateScheduleParams struct {
	Title          string         `json:"title"`
	Timezone       string         `json:"timezone"`
	Rrule          string         `json:"rrule"`
	StartDateIso   string         `json:"start_date_iso"`
	EndDateIso     sql.NullString `json:"end_date_iso"`
	LockoutMinutes int64          `json:"lockout_minutes"`
	Status         string         `json:"status"`
	ID             string         `json:"id"`
}

func (q *Queries) UpdateSchedule(ctx context.Context, arg UpdateScheduleParams) (Schedule, error) {
	row := q.queryRow(ctx, q.updateScheduleStmt, updateSchedule,
		arg.Title,
		arg.Timezone,
		arg.Rrule,
		arg.StartDateIso,
		arg.EndDateIso,
		arg.LockoutMinutes,
		arg.Status,
		arg.ID,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.Title,
		&i.Timezone,
		&i.Rrule,
		&i.StartDateIso,
		&i.EndDateIso,
		&i.LockoutMinutes,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
